<!DOCTYPE html>
<html><head>
	<title>inveniemus</title>
	<link rel="stylesheet" href="api.css">
</head><body>
	<div id="api_index">
		<h3><a href="#">Index</a></h3>
		<ul><li><span class="item_new"><a href="#Element"><code>Element</code></a></span><ul><li><span class=""><a href="#Element.arrayMapping"><code>arrayMapping</code></a></span></li><li><span class=""><a href="#Element.clone"><code>clone</code></a></span></li><li><span class=""><a href="#Element.emblem"><code>emblem</code></a></span></li><li><span class=""><a href="#Element.equals"><code>equals</code></a></span></li><li><span class=""><a href="#Element.euclideanDistance"><code>euclideanDistance</code></a></span></li><li><span class=""><a href="#Element.evaluate"><code>evaluate</code></a></span></li><li><span class=""><a href="#Element.evaluation"><code>evaluation</code></a></span></li><li><span class=""><a href="#Element.hammingDistance"><code>hammingDistance</code></a></span></li><li><span class=""><a href="#Element.length"><code>length</code></a></span></li><li><span class=""><a href="#Element.manhattanDistance"><code>manhattanDistance</code></a></span></li><li><span class=""><a href="#Element.mapping"><code>mapping</code></a></span></li><li><span class=""><a href="#Element.maximumValue"><code>maximumValue</code></a></span></li><li><span class=""><a href="#Element.minimumValue"><code>minimumValue</code></a></span></li><li><span class=""><a href="#Element.modification"><code>modification</code></a></span></li><li><span class=""><a href="#Element.neighbourhood"><code>neighbourhood</code></a></span></li><li><span class=""><a href="#Element.random"><code>random</code></a></span></li><li><span class=""><a href="#Element.randomValue"><code>randomValue</code></a></span></li><li><span class=""><a href="#Element.randomValues"><code>randomValues</code></a></span></li><li><span class=""><a href="#Element.resolution"><code>resolution</code></a></span></li><li><span class=""><a href="#Element.rootMeanSquaredError"><code>rootMeanSquaredError</code></a></span></li><li><span class=""><a href="#Element.setMapping"><code>setMapping</code></a></span></li><li><span class=""><a href="#Element.successors"><code>successors</code></a></span></li><li><span class=""><a href="#Element.suffices"><code>suffices</code></a></span></li><li><span class=""><a href="#Element.values"><code>values</code></a></span></li></ul></li><li><span class="item_new"><a href="#Metaheuristic"><code>Metaheuristic</code></a></span><ul><li><span class=""><a href="#Metaheuristic.advance"><code>advance</code></a></span></li><li><span class=""><a href="#Metaheuristic.analyze"><code>analyze</code></a></span></li><li><span class=""><a href="#Metaheuristic.evaluate"><code>evaluate</code></a></span></li><li><span class=""><a href="#Metaheuristic.events"><code>events</code></a></span></li><li><span class=""><a href="#Metaheuristic.expand"><code>expand</code></a></span></li><li><span class=""><a href="#Metaheuristic.expansion"><code>expansion</code></a></span></li><li><span class=""><a href="#Metaheuristic.finished"><code>finished</code></a></span></li><li><span class=""><a href="#Metaheuristic.initiate"><code>initiate</code></a></span></li><li><span class=""><a href="#Metaheuristic.logger"><code>logger</code></a></span></li><li><span class=""><a href="#Metaheuristic.problem"><code>problem</code></a></span></li><li><span class=""><a href="#Metaheuristic.prototype.sieve"><code>prototype.sieve</code></a></span></li><li><span class=""><a href="#Metaheuristic.random"><code>random</code></a></span></li><li><span class=""><a href="#Metaheuristic.reset"><code>reset</code></a></span></li><li><span class=""><a href="#Metaheuristic.run"><code>run</code></a></span></li><li><span class=""><a href="#Metaheuristic.size"><code>size</code></a></span></li><li><span class=""><a href="#Metaheuristic.state"><code>state</code></a></span></li><li><span class=""><a href="#Metaheuristic.statistics"><code>statistics</code></a></span></li><li><span class=""><a href="#Metaheuristic.step"><code>step</code></a></span></li><li><span class=""><a href="#Metaheuristic.steps"><code>steps</code></a></span></li><li><span class=""><a href="#Metaheuristic.update"><code>update</code></a></span></li></ul></li><li><span class=""><a href="#metaheuristics"><code>metaheuristics</code></a></span><ul><li><span class="item_new"><a href="#metaheuristics.BeamSearch"><code>BeamSearch</code></a></span><ul><li><span class=""><a href="#metaheuristics.BeamSearch.expansion"><code>expansion</code></a></span></li><li><span class=""><a href="#metaheuristics.BeamSearch.successors"><code>successors</code></a></span></li></ul></li><li><span class="item_new"><a href="#metaheuristics.GeneticAlgorithm"><code>GeneticAlgorithm</code></a></span><ul><li><span class=""><a href="#metaheuristics.GeneticAlgorithm.crossover"><code>crossover</code></a></span></li><li><span class=""><a href="#metaheuristics.GeneticAlgorithm.crossovers"><code>crossovers</code></a></span><ul><li><span class=""><a href="#metaheuristics.GeneticAlgorithm.crossovers.singlepointCrossover"><code>singlepointCrossover</code></a></span></li></ul></li><li><span class=""><a href="#metaheuristics.GeneticAlgorithm.expansion"><code>expansion</code></a></span></li><li><span class=""><a href="#metaheuristics.GeneticAlgorithm.expansionRate"><code>expansionRate</code></a></span></li><li><span class=""><a href="#metaheuristics.GeneticAlgorithm.mutation"><code>mutation</code></a></span></li><li><span class=""><a href="#metaheuristics.GeneticAlgorithm.mutationRate"><code>mutationRate</code></a></span></li><li><span class=""><a href="#metaheuristics.GeneticAlgorithm.mutations"><code>mutations</code></a></span><ul><li><span class=""><a href="#metaheuristics.GeneticAlgorithm.mutations.singlepointBiasedMutation"><code>singlepointBiasedMutation</code></a></span></li><li><span class=""><a href="#metaheuristics.GeneticAlgorithm.mutations.singlepointUniformMutation"><code>singlepointUniformMutation</code></a></span></li><li><span class=""><a href="#metaheuristics.GeneticAlgorithm.mutations.uniformMutation"><code>uniformMutation</code></a></span></li></ul></li><li><span class=""><a href="#metaheuristics.GeneticAlgorithm.selection"><code>selection</code></a></span><ul><li><span class=""><a href="#metaheuristics.GeneticAlgorithm.selection.rankSelection"><code>rankSelection</code></a></span></li></ul></li><li><span class="item_static"><a href="#metaheuristics.GeneticAlgorithm.selections"><code>selections</code></a></span><ul><li><span class=""><a href="#metaheuristics.GeneticAlgorithm.selections.rouletteSelection"><code>rouletteSelection</code></a></span></li></ul></li></ul></li><li><span class="item_new"><a href="#metaheuristics.HillClimbing"><code>HillClimbing</code></a></span><ul><li><span class=""><a href="#metaheuristics.HillClimbing.atLocalOptima"><code>atLocalOptima</code></a></span></li><li><span class=""><a href="#metaheuristics.HillClimbing.delta"><code>delta</code></a></span></li><li><span class=""><a href="#metaheuristics.HillClimbing.finished"><code>finished</code></a></span></li><li><span class=""><a href="#metaheuristics.HillClimbing.size"><code>size</code></a></span></li><li><span class=""><a href="#metaheuristics.HillClimbing.update"><code>update</code></a></span></li></ul></li><li><span class="item_new"><a href="#metaheuristics.SimulatedAnnealing"><code>SimulatedAnnealing</code></a></span><ul><li><span class=""><a href="#metaheuristics.SimulatedAnnealing.acceptance"><code>acceptance</code></a></span></li><li><span class=""><a href="#metaheuristics.SimulatedAnnealing.delta"><code>delta</code></a></span></li><li><span class=""><a href="#metaheuristics.SimulatedAnnealing.maximumTemperature"><code>maximumTemperature</code></a></span></li><li><span class=""><a href="#metaheuristics.SimulatedAnnealing.minimumTemperature"><code>minimumTemperature</code></a></span></li><li><span class=""><a href="#metaheuristics.SimulatedAnnealing.randomNeighbour"><code>randomNeighbour</code></a></span></li><li><span class=""><a href="#metaheuristics.SimulatedAnnealing.size"><code>size</code></a></span></li><li><span class=""><a href="#metaheuristics.SimulatedAnnealing.temperature"><code>temperature</code></a></span></li><li><span class=""><a href="#metaheuristics.SimulatedAnnealing.update"><code>update</code></a></span></li></ul></li></ul></li><li><span class="item_new"><a href="#Problem"><code>Problem</code></a></span><ul><li><span class=""><a href="#Problem.approximation"><code>approximation</code></a></span></li><li><span class=""><a href="#Problem.compare"><code>compare</code></a></span></li><li><span class=""><a href="#Problem.description"><code>description</code></a></span></li><li><span class=""><a href="#Problem.maximization"><code>maximization</code></a></span></li><li><span class=""><a href="#Problem.minimization"><code>minimization</code></a></span></li><li><span class=""><a href="#Problem.random"><code>random</code></a></span></li><li><span class=""><a href="#Problem.representation"><code>representation</code></a></span></li><li><span class=""><a href="#Problem.suffices"><code>suffices</code></a></span></li><li><span class=""><a href="#Problem.title"><code>title</code></a></span></li></ul></li><li><span class=""><a href="#problems"><code>problems</code></a></span><ul><li><span class="item_new"><a href="#problems.HelloWorld"><code>HelloWorld</code></a></span></li><li><span class="item_new"><a href="#problems.KnapsackProblem"><code>KnapsackProblem</code></a></span><ul><li><span class=""><a href="#problems.KnapsackProblem.defaultAmount"><code>defaultAmount</code></a></span></li><li><span class=""><a href="#problems.KnapsackProblem.items"><code>items</code></a></span></li><li><span class=""><a href="#problems.KnapsackProblem.limit"><code>limit</code></a></span></li><li><span class=""><a href="#problems.KnapsackProblem.representation"><code>representation</code></a></span></li></ul></li><li><span class="item_new"><a href="#problems.NQueensPuzzle"><code>NQueensPuzzle</code></a></span><ul><li><span class=""><a href="#problems.NQueensPuzzle.representation"><code>representation</code></a></span></li></ul></li><li><span class="item_new"><a href="#problems.SumOptimization"><code>SumOptimization</code></a></span><ul><li><span class=""><a href="#problems.SumOptimization.compare"><code>compare</code></a></span></li><li><span class=""><a href="#problems.SumOptimization.suffices"><code>suffices</code></a></span></li></ul>
	</div>
	<div id="api_detail">
		<header>
			<h1>inveniemus</h1>
			<p>A search and optimization library, focusing on metaheuristics.</p>
		</header>
	
		<div>
			<h4><span class="item_new">
				<a name="Element"></a>
				<code>new Element(values=&lt;random values&gt;, evaluation=NaN):</code>
			</span></h4>
			
				<p>
An element represents a candidate solution. It is defined by the values
array of numbers, between minimumValue and maximumValue (by default 0
and 1).</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.arrayMapping"></a>
				<code>Element.arrayMapping(items...):</code>
			</span></h4>
			
				<p>
Builds an array of equal length of this element's values. Each value is
used to index the corresponding items argument. If there are less
arguments than the element's length, the last one is used for the rest
of the values.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.clone"></a>
				<code>Element.clone():</code>
			</span></h4>
			
				<p>
Returns a copy of this element.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.emblem"></a>
				<code>Element.emblem():</code>
			</span></h4>
			
				<p>
The emblem of an element is a string that represents it and can	be
displayed to the user. By default returns the string conversion.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.equals"></a>
				<code>Element.equals(other):</code>
			</span></h4>
			
				<p>
Checks if the other element has the same values and constructor than
this one.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.euclideanDistance"></a>
				<code>Element.euclideanDistance(array1, array2):</code>
			</span></h4>
			
				<p>
Calculates the <a href="http://en.wikipedia.org/wiki/Euclidean_distance" target="_blank">euclidean distance</a>
between two arrays. Arrays are assumed to be of the same length. If they
are not, only the common parts are considered.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.evaluate"></a>
				<code>Element.evaluate():</code>
			</span></h4>
			
				<p>
Evaluates this element, assigning its evaluation and returning it. It
can return a Future if the evaluation has to be done asynchronously.</p>
			
				<p>This can be interpreted as the solutions cost in a search problem or the
target function of an optimization problem. The default behaviour is
adding up this element's values, useful only for testing.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.evaluation"></a>
				<code>Element.evaluation=NaN:</code>
			</span></h4>
			
				<p>
The element's evaluation is a measure of its fitness to solve a
problem. It guides almost all of the metaheuristics.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.hammingDistance"></a>
				<code>Element.hammingDistance(array1, array2):</code>
			</span></h4>
			
				<p>
The <a href="http://en.wikipedia.org/wiki/Hamming_distance" target="_blank">Hamming distance</a>
between two arrays is the number of positions at which corresponding
components are different. Arrays are assumed to be of the same
length. If they are not, only the common parts are considered.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.length"></a>
				<code>Element.length=10:</code>
			</span></h4>
			
				<p>
Size of the element's values array.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.manhattanDistance"></a>
				<code>Element.manhattanDistance(array1, array2):</code>
			</span></h4>
			
				<p>
The <a href="http://en.wikipedia.org/wiki/Manhattan_distance" target="_blank">Manhattan distance</a>
between two arrays is the sum of the absolute differences of
corresponding positions. Arrays are assumed to be of the same length. If
they are not, only the common parts are considered.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.mapping"></a>
				<code>Element.mapping():</code>
			</span></h4>
			
				<p>
Returns an alternate representation of this element that may be fitter
for evaluation or showing it to the user. By default it just returns the
values array.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.maximumValue"></a>
				<code>Element.maximumValue=1:</code>
			</span></h4>
			
				<p>
Maximum value a number in this element can have.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.minimumValue"></a>
				<code>Element.minimumValue=0:</code>
			</span></h4>
			
				<p>
Minimum value a number in this element can have.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.modification"></a>
				<code>Element.modification(index, value, ...):</code>
			</span></h4>
			
				<p>
Returns a new and unevaluated copy of this element, with its values
modified as specified.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.neighbourhood"></a>
				<code>Element.neighbourhood(radius=1%):</code>
			</span></h4>
			
				<p>
Returns an array of new elements, with values belonging to the n
dimensional ball around this element's values.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.random"></a>
				<code>Element.random=Randomness.DEFAULT:</code>
			</span></h4>
			
				<p>
Pseudorandom number generator used by the element.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.randomValue"></a>
				<code>Element.randomValue():</code>
			</span></h4>
			
				<p>
Returns a random value between this.minimumValue and this.maximumValue.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.randomValues"></a>
				<code>Element.randomValues():</code>
			</span></h4>
			
				<p>
Returns an array with random numbers.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.resolution"></a>
				<code>Element.resolution=Number.EPSILON:</code>
			</span></h4>
			
				<p>
Minimum difference between two evaluation to consider them different.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.rootMeanSquaredError"></a>
				<code>Element.rootMeanSquaredError(f, data):</code>
			</span></h4>
			
				<p>
Returns the <a href="http://en.wikipedia.org/wiki/Root_mean_squared_error" target="_blank">root mean squared error</a>
of the function f on the given data. The data must be an iterable of
arrays, in which the first element is the expected result and the rest
are the arguments for the function.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.setMapping"></a>
				<code>Element.setMapping(items):</code>
			</span></h4>
			
				<p>
Builds an array of equal length of this element's values. Each value is
used to select one item. Items are not selected more than once.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.successors"></a>
				<code>Element.successors():</code>
			</span></h4>
			
				<p>
Returns an array with new elements that can be considered adjacent of
this element. By default returns the element's neighbourhood with the
default radius.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.suffices"></a>
				<code>Element.suffices():</code>
			</span></h4>
			
				<p>
Returns true if this element is an actual solution to the problem. It
holds the implementation of the goal test in search problems. More
complex criteria may be implemented in Problem.suffices.</p>
			
				<p>By default it checks if the values add up to zero.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Element.values"></a>
				<code>Element.values:</code>
			</span></h4>
			
				<p>
An array of numbers that represents a candidate solution.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="Metaheuristic"></a>
				<code>new Metaheuristic(params):</code>
			</span></h4>
			
				<p>
Base class of all metaheuristic algorithms, and hence of all
metaheuristic runs.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Metaheuristic.advance"></a>
				<code>Metaheuristic.advance():</code>
			</span></h4>
			
				<p>
Performs one step of the optimization. If the process has not been
initialized, it does so. Returns a Future if the run has not finished or
null otherwise.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Metaheuristic.analyze"></a>
				<code>Metaheuristic.analyze():</code>
			</span></h4>
			
				<p>
Updates the process' statistics.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Metaheuristic.evaluate"></a>
				<code>Metaheuristic.evaluate(elements):</code>
			</span></h4>
			
				<p>
Evaluates all the elements in this.state with no evaluation, using its
evaluation method. After that sorts the state with the compare method
of the problem.</p>
			
				<p>Returns a Future, regardless of the evaluation being asynchronous or
not.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Metaheuristic.events"></a>
				<code>Metaheuristic.events:</code>
			</span></h4>
			
				<p>
Event handler for this metaheuristic. The emitted events by default
are: initiated, updated, expanded, evaluated, sieved, advanced,
analyzed &amp; finished.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Metaheuristic.expand"></a>
				<code>Metaheuristic.expand(expansion=[]):</code>
			</span></h4>
			
				<p>
Adds to this metaheuristic's state the given expansion. If none is given,
this.expansion() is called to get new expansion.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Metaheuristic.expansion"></a>
				<code>Metaheuristic.expansion(size):</code>
			</span></h4>
			
				<p>
Returns an array of new elements to add to the current state. The
default implementation generates new random elements.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Metaheuristic.finished"></a>
				<code>Metaheuristic.finished():</code>
			</span></h4>
			
				<p>
Termination criteria for this metaheuristic. By default it checks if the
number of passed iterations is not greater than this.steps.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Metaheuristic.initiate"></a>
				<code>Metaheuristic.initiate(size=this.size):</code>
			</span></h4>
			
				<p>
Builds and initiates this metaheuristic state with size new cursors. The
elements are build using the initial() function.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Metaheuristic.logger"></a>
				<code>Metaheuristic.logger:</code>
			</span></h4>
			
				<p>
Logger used by the metaheuristic.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Metaheuristic.problem"></a>
				<code>Metaheuristic.problem:</code>
			</span></h4>
			
				<p>
Definition of the problem this metaheuristic will try to solve.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Metaheuristic.prototype.sieve"></a>
				<code>Metaheuristic.prototype.sieve(size=this.size):</code>
			</span></h4>
			
				<p>
Cuts the current state down to the given size (or this.size by default).</p>
			
				<p>This is usually used after expanding and evaluating the state. The
statistics of this metaheuristic are calculated here, right after the
state is sieved.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Metaheuristic.random"></a>
				<code>Metaheuristic.random=Randomness.DEFAULT:</code>
			</span></h4>
			
				<p>
This metaheuristic's pseudorandom number generator. It is strongly
advised to have only one for the whole process.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Metaheuristic.reset"></a>
				<code>Metaheuristic.reset():</code>
			</span></h4>
			
				<p>
Reset the process to start over again. Basically cleans the stats and
sets the current step to -1.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Metaheuristic.run"></a>
				<code>Metaheuristic.run():</code>
			</span></h4>
			
				<p>
Returns a Future that is resolved when the whole search process is
finished. The value is the best cursor after the last step.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Metaheuristic.size"></a>
				<code>Metaheuristic.size=100:</code>
			</span></h4>
			
				<p>
Amount of candidate solutions the metaheuristic treats at each step.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Metaheuristic.state"></a>
				<code>Metaheuristic.state=[]:</code>
			</span></h4>
			
				<p>
An array holding the elements this metaheuristic handles at each
step.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Metaheuristic.statistics"></a>
				<code>Metaheuristic.statistics:</code>
			</span></h4>
			
				<p>
The statistic gatherer for this metaheuristic.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Metaheuristic.step"></a>
				<code>Metaheuristic.step=-1:</code>
			</span></h4>
			
				<p>
Current iteration of this metaheuristic, or a negative number if
it has not started yet.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Metaheuristic.steps"></a>
				<code>Metaheuristic.steps=100:</code>
			</span></h4>
			
				<p>
Number of steps this metaheuristic must perform.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Metaheuristic.update"></a>
				<code>Metaheuristic.update():</code>
			</span></h4>
			
				<p>
Updates this metaheuristic's state. It assumes the state has been
initialized. The process may be asynchronous, so it returns a Future.</p>
			
				<p>The default implementation first expands the state by calling
this.expand(), then evaluates the added elements by calling
this.evaluate(), and finally removes the worst elements with
this.sieve().</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics"></a>
				<code>metaheuristics:</code>
			</span></h4>
			
				<p>
Bundle of metaheuristics available.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="metaheuristics.BeamSearch"></a>
				<code>new metaheuristics.BeamSearch(params):</code>
			</span></h4>
			
				<p>
Builds a beam search. The problem's element must have its successors
method implemented.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.BeamSearch.expansion"></a>
				<code>metaheuristics.BeamSearch.expansion():</code>
			</span></h4>
			
				<p>
Successors to all elements are calculated by calling the problem's
successors method.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.BeamSearch.successors"></a>
				<code>metaheuristics.BeamSearch.successors(element):</code>
			</span></h4>
			
				<p>
Returns the elements' successors. By default returns
element.successors().</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="metaheuristics.GeneticAlgorithm"></a>
				<code>new metaheuristics.GeneticAlgorithm(params):</code>
			</span></h4>
			
				<p>
Builds a genetic algorithm, the base for many evolutionary computing
variants.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.GeneticAlgorithm.crossover"></a>
				<code>metaheuristics.GeneticAlgorithm.crossover(parents):</code>
			</span></h4>
			
				<p>
Genetic operator that simulates reproduction with inheritance. The
parents argument must be an array of elements. The result is an
array of elements.</p>
			
				<p>By default the single point crossover is used.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.GeneticAlgorithm.crossovers"></a>
				<code>metaheuristics.GeneticAlgorithm.crossovers:</code>
			</span></h4>
			
				<p>
Bundle of standard crossover methods. A crossover function takes an
array of parent elements and returns an array of sibling elements.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.GeneticAlgorithm.crossovers.singlepointCrossover"></a>
				<code>metaheuristics.GeneticAlgorithm.crossovers.singlepointCrossover(parents):</code>
			</span></h4>
			
				<p>
Given two parents, returns an array of two new elements built with one
half of each parent. The cutpoint is chosen randomly.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.GeneticAlgorithm.expansion"></a>
				<code>metaheuristics.GeneticAlgorithm.expansion():</code>
			</span></h4>
			
				<p>
Returns the possibly mutated crossovers of selected elements. How many
is determined by this.expansionRate.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.GeneticAlgorithm.expansionRate"></a>
				<code>metaheuristics.GeneticAlgorithm.expansionRate=0.5:</code>
			</span></h4>
			
				<p>
The amount of new elements generated by crossover, as a ratio of the
population size.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.GeneticAlgorithm.mutation"></a>
				<code>metaheuristics.GeneticAlgorithm.mutation(element):</code>
			</span></h4>
			
				<p>
Genetic operator that simulates biological mutation, making a random
change in the chromosome.</p>
			
				<p>By default a single point uniform mutation is used.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.GeneticAlgorithm.mutationRate"></a>
				<code>metaheuristics.GeneticAlgorithm.mutationRate=0.2:</code>
			</span></h4>
			
				<p>
The chance of a new element (resulting from crossover) mutating.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.GeneticAlgorithm.mutations"></a>
				<code>metaheuristics.GeneticAlgorithm.mutations:</code>
			</span></h4>
			
				<p>
Bundle of standard mutation methods.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.GeneticAlgorithm.mutations.singlepointBiasedMutation"></a>
				<code>metaheuristics.GeneticAlgorithm.mutations.singlepointBiasedMutation(element):</code>
			</span></h4>
			
				<p>
Sets a randomly selected gene to random deviation of its value, with a
triangular distribution.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.GeneticAlgorithm.mutations.singlepointUniformMutation"></a>
				<code>metaheuristics.GeneticAlgorithm.mutations.singlepointUniformMutation(element):</code>
			</span></h4>
			
				<p>
Sets a randomly selected gene to a uniform random value.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.GeneticAlgorithm.mutations.uniformMutation"></a>
				<code>metaheuristics.GeneticAlgorithm.mutations.uniformMutation(maxPoints=Infinity):</code>
			</span></h4>
			
				<p>
Builds a mutation function that makes at least one and up to maxPoints
mutations, changing a randomly selected gene to a uniform random value.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.GeneticAlgorithm.selection"></a>
				<code>metaheuristics.GeneticAlgorithm.selection(count):</code>
			</span></h4>
			
				<p>
Selects count elements from the current population. These will be
the parents of the new elements in the next generation.</p>
			
				<p>By default rank selection is used, a.k.a. fitness proportional
to position in the state.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.GeneticAlgorithm.selection.rankSelection"></a>
				<code>metaheuristics.GeneticAlgorithm.selection.rankSelection(count=2):</code>
			</span></h4>
			
				<p>
Makes a selection where each element's probability of being selected is
proportional to its position in the state.</p>
			
		</div>
	
		<div>
			<h4><span class="item_static">
				<a name="metaheuristics.GeneticAlgorithm.selections"></a>
				<code>static metaheuristics.GeneticAlgorithm.selections:</code>
			</span></h4>
			
				<p>
Bundle of standard selection methods. A selection function takes the
amount of elements to be selected and returns an array of selected
elements.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.GeneticAlgorithm.selections.rouletteSelection"></a>
				<code>metaheuristics.GeneticAlgorithm.selections.rouletteSelection(count=2):</code>
			</span></h4>
			
				<p>
Makes a selection where each element's probability of being selected is
proportional to its evaluation.</p>
			
				<p>Warning! This selection assumes the evaluation is being maximized.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="metaheuristics.HillClimbing"></a>
				<code>new metaheuristics.HillClimbing(params):</code>
			</span></h4>
			
				<p>
Builds a <a href="http://en.wikipedia.org/wiki/Hill_climbing" target="_blank">hill climbing</a>
search.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.HillClimbing.atLocalOptima"></a>
				<code>metaheuristics.HillClimbing.atLocalOptima():</code>
			</span></h4>
			
				<p>
Checks if the search is currently stuck at local optima.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.HillClimbing.delta"></a>
				<code>metaheuristics.HillClimbing.delta=0.01:</code>
			</span></h4>
			
				<p>
The radius of the elements surroundings in every dimension, that is
checked by this algorithm.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.HillClimbing.finished"></a>
				<code>metaheuristics.HillClimbing.finished():</code>
			</span></h4>
			
				<p>
Hill climbing search must finish when a local optimum is reached. This
criteria is tested together with all others.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.HillClimbing.size"></a>
				<code>metaheuristics.HillClimbing.size=1:</code>
			</span></h4>
			
				<p>
Default value for size is 1.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.HillClimbing.update"></a>
				<code>metaheuristics.HillClimbing.update():</code>
			</span></h4>
			
				<p>
Each element in the state is replaced by the best element in its
neighbourhood, if there is any. The surroundings have all possible
elements resulting from either an increment or decrement (of the given
delta) in each of the centre element's dimensions.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="metaheuristics.SimulatedAnnealing"></a>
				<code>new metaheuristics.SimulatedAnnealing(params):</code>
			</span></h4>
			
				<p>
Builds a simulated annealing search.</p>
			
				<p>See &lt;http://en.wikipedia.org/wiki/Simulated_annealing&gt;.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.SimulatedAnnealing.acceptance"></a>
				<code>metaheuristics.SimulatedAnnealing.acceptance(current, neighbour, temp=this.temperature()):</code>
			</span></h4>
			
				<p>
Returns the probability of accepting the new element. Uses the original
definitions from Kirkpatrick's paper.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.SimulatedAnnealing.delta"></a>
				<code>metaheuristics.SimulatedAnnealing.delta=0.01:</code>
			</span></h4>
			
				<p>
The radius of the elements surroundings in every dimension, that is
checked by this algorithm.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.SimulatedAnnealing.maximumTemperature"></a>
				<code>metaheuristics.SimulatedAnnealing.maximumTemperature=1:</code>
			</span></h4>
			
				<p>
The temperature at the start of the run.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.SimulatedAnnealing.minimumTemperature"></a>
				<code>metaheuristics.SimulatedAnnealing.minimumTemperature=1:</code>
			</span></h4>
			
				<p>
The temperature at the end of the run.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.SimulatedAnnealing.randomNeighbour"></a>
				<code>metaheuristics.SimulatedAnnealing.randomNeighbour(element, radius=this.delta):</code>
			</span></h4>
			
				<p>
Returns one neighbour of the given element chosen at random.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.SimulatedAnnealing.size"></a>
				<code>metaheuristics.SimulatedAnnealing.size=1:</code>
			</span></h4>
			
				<p>
Default value for size is 1.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.SimulatedAnnealing.temperature"></a>
				<code>metaheuristics.SimulatedAnnealing.temperature():</code>
			</span></h4>
			
				<p>
Returns the current temperature of the annealing.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="metaheuristics.SimulatedAnnealing.update"></a>
				<code>metaheuristics.SimulatedAnnealing.update():</code>
			</span></h4>
			
				<p>
For each element in the state one of its neighbours is chosen randomly. If
the neighbour is better, it replaces the corresponding element. Else it
may still do so, but with a probability calculated by this.acceptance().</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="Problem"></a>
				<code>new Problem(params):</code>
			</span></h4>
			
				<p>
A search/optimization problem definition, holding the representation of
the elements (as an Element constructor), with the comparison and
sufficiency criteria.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Problem.approximation"></a>
				<code>Problem.approximation(target, element1, element2):</code>
			</span></h4>
			
				<p>
Compares two elements by distance of its evaluation to the given target
value in ascending order.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Problem.compare"></a>
				<code>Problem.compare(element1, element2):</code>
			</span></h4>
			
				<p>
Standard comparison function between two elements. Returns a positive
number if element2 is better than element1, a negative number if
element2 is worse then element1, or zero otherwise.</p>
			
				<p>Implements a minimization by default.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Problem.description"></a>
				<code>Problem.description='&lt;no description&gt;':</code>
			</span></h4>
			
				<p>
Description of the problem to be displayed to the user.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Problem.maximization"></a>
				<code>Problem.maximization(element1, element2):</code>
			</span></h4>
			
				<p>
Compares two elements by evaluation in descending order.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Problem.minimization"></a>
				<code>Problem.minimization(element1, element2):</code>
			</span></h4>
			
				<p>
Compares two elements by evaluation in ascending order.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Problem.random"></a>
				<code>Problem.random=Randomness.DEFAULT:</code>
			</span></h4>
			
				<p>
Pseudorandom number generator used by the problem.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Problem.representation"></a>
				<code>Problem.representation=Element:</code>
			</span></h4>
			
				<p>
Element constructor used for this problem's candidate solutions.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Problem.suffices"></a>
				<code>Problem.suffices(elements):</code>
			</span></h4>
			
				<p>
Returns true if inside the elements array there is an actual solution to
the problem. It holds the implementation of the goal test in search
problems.</p>
			
				<p>By default checks if the first element by calling its suffice method.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="Problem.title"></a>
				<code>Problem.title='&lt;no title&gt;':</code>
			</span></h4>
			
				<p>
Title of the problem to be displayed to the user.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="problems"></a>
				<code>problems:</code>
			</span></h4>
			
				<p>
Bundle of classic and reference problems.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="problems.HelloWorld"></a>
				<code>new problems.HelloWorld(params):</code>
			</span></h4>
			
				<p>
Simple problem where each element is a string, and the optimization
goes towards the target string. The string to match is specified by the
'target' parameter.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="problems.KnapsackProblem"></a>
				<code>new problems.KnapsackProblem(params):</code>
			</span></h4>
			
				<p>
Classic combinatorial optimization problem, based on a given a set of
items, each with a cost and a worth. The solution is a subset of items
with maximum worth sum that does not exceed a cost limit.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="problems.KnapsackProblem.defaultAmount"></a>
				<code>problems.KnapsackProblem.defaultAmount=1:</code>
			</span></h4>
			
				<p>
Amount available for each item by default.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="problems.KnapsackProblem.items"></a>
				<code>problems.KnapsackProblem.items:</code>
			</span></h4>
			
				<p>
The superset of all candidate solutions. Must be an object with each
item by name. Each item must have a cost and a worth, and may have an
amount (1 by default).</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="problems.KnapsackProblem.limit"></a>
				<code>problems.KnapsackProblem.limit=15:</code>
			</span></h4>
			
				<p>
Cost limit that candidate solution should not exceed.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="problems.KnapsackProblem.representation"></a>
				<code>problems.KnapsackProblem.representation:</code>
			</span></h4>
			
				<p>
The representation is an array with a number for each item. This
number holds the selected amount for each item (from 0 up to the
item's amount).</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="problems.NQueensPuzzle"></a>
				<code>new problems.NQueensPuzzle(params):</code>
			</span></h4>
			
				<p>
Generalized version of the classic problem of placing 8 chess queens on
an 8x8 chessboard so that no two queens attack each other. The amount
of queens and board dimensions is specified by the N parameter.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="problems.NQueensPuzzle.representation"></a>
				<code>problems.NQueensPuzzle.representation:</code>
			</span></h4>
			
				<p>
The representation is an array of N positions, indicating the row of
the queen for each column. Its evaluation is the count of diagonals
shared by queens pairwise.</p>
			
		</div>
	
		<div>
			<h4><span class="item_new">
				<a name="problems.SumOptimization"></a>
				<code>new problems.SumOptimization(params):</code>
			</span></h4>
			
				<p>
Very simple problem based on optimizing the elements' values sum. The
params argument should include the 'target' number.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="problems.SumOptimization.compare"></a>
				<code>problems.SumOptimization.compare(element1, element2):</code>
			</span></h4>
			
				<p>
The comparison between elements depends on this problem's target. For
a Infinity maximization is applied, for -Infinity minimization, and
for every other number approximation.</p>
			
		</div>
	
		<div>
			<h4><span class="">
				<a name="problems.SumOptimization.suffices"></a>
				<code>problems.SumOptimization.suffices(elements):</code>
			</span></h4>
			
				<p>
Checks if the best element's values add up to the target value.</p>
			
		</div>
	
		<footer>inveniemus (version 0.1.0) by <a href="mailto:leonardo.val@creatartis.com>">Leonardo Val</a>.</footer>
	</div>
</body></html>