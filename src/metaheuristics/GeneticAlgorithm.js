/** Classic Holland's-style [genetic algorithms](http://en.wikipedia.org/wiki/Genetic_algorithm)
	for the Inveniemus library.
*/
// GeneticAlgorithm metaheuristic. /////////////////////////////////////////////
var GeneticAlgorithm = metaheuristics.GeneticAlgorithm = basis.declare(Metaheuristic, {
	/** new GeneticAlgorithm(params):
		Builds a genetic algorithm, the base for many evolutionary computing
		variants.
	*/
	constructor: function GeneticAlgorithm(params) {
		Metaheuristic.call(this, params); // Superconstructor call.
		basis.initialize(this, params)
		/** GeneticAlgorithm.expansionRate=0.5:
			The amount of new elements generated by crossover, as a ratio of the
			population size.
		*/
			.number('expansionRate', { defaultValue: 0.5, minimum: 0, coerce: true })
		/** GeneticAlgorithm.mutationRate=0.2:
			The chance of a new element (resulting from crossover) mutating.
		*/
			.number('mutationRate', { defaultValue: 0.2, minimum: 0, maximum: 1, coerce: true })
		/** GeneticAlgorithm.selection(count):
			Selects count elements from the current population. These will be 
			the parents of the new elements in the next generation.
			By default rank selection is used, a.k.a. fitness proportional
			to position in the state.
		*/
			.func('selection', { defaultValue: GeneticAlgorithm.selections.rankSelection })
		/** GeneticAlgorithm.crossover(parents):
			Genetic operator that simulates reproduction with inheritance. The 
			parents argument must be an array of elements. The result is an 
			array of elements.
			By default the single point crossover is used.
		*/
			.func('crossover', { defaultValue: GeneticAlgorithm.crossovers.singlepointCrossover })
		/** GeneticAlgorithm.mutation(element):
			Genetic operator that simulates biological mutation, making a random
			change in the chromosome.
			By default a single point uniform mutation is used.
		*/
			.func('mutation', { defaultValue: GeneticAlgorithm.mutations.singlepointUniformMutation });
	},

	/** GeneticAlgorithm.expansion():
		Returns the possibly mutated crossovers of selected elements. How many 
		is determined by this.expansionRate.
	*/
	expansion: function expansion() {
		var parents, childs, child,
			newElements = [],
			len = Math.floor(this.expansionRate * this.size);
		len += len % 2; // Make len even.
		for (var i = 0; i < len; i += 2) {
			parents = this.selection();
			childs = this.crossover(parents);
			for (var j = 0; j < childs.length; j++) {
				child = this.random.randomBool(this.mutationRate) ? this.mutation(childs[j]) : childs[j];
				newElements.push(child);
			}
		}
		return newElements;
	},
	
	// Utility methods. ////////////////////////////////////////////////////////
	
	toString: function toString() {
		return (this.constructor.name || 'GeneticAlgorithm')+ '('+ JSON.stringify(this) +')';
	}
}); // declare GeneticAlgorithm.
	
/** static GeneticAlgorithm.selections:
	Bundle of standard selection methods. A selection function takes the
	amount of elements to be selected and returns an array of selected
	elements.
*/
GeneticAlgorithm.selections = {
	/** GeneticAlgorithm.selection.rankSelection(count=2):
		Makes a selection where each element's probability of being selected is
		proportional to its position in the state.
	*/
	rankSelection: function rankSelection(count) {
		count = isNaN(count) ? 2 : +count;
		var len = this.state.length,
			randoms = this.random.randoms(count, 0, len * (len + 1) / 2 - 1),
			selected = [];
		randoms.sort(function (x, y) { 
			return x - y; 
		});
		this.state.forEach(function (element) {
			for (var i = 0; i < count; i++) {
				randoms[i] += i - len;
			}
			if (randoms[0] <= 0) {
				selected.push(element);
				randoms.shift();
			}
		});
		if (selected.length < count) { // Should not happen.
			selected = selected.concat(this.state.slice(0, count - selected.length));
		}
		return selected;
	},
	
	/** GeneticAlgorithm.selections.rouletteSelection(count=2):
		Makes a selection where each element's probability of being selected is
		proportional to its evaluation.
		Warning! This selection assumes the evaluation is being maximized.
	*/
	rouletteSelection: function rouletteSelection(count) { //FIXME
	/* this.statistics.stat('evaluations_step').minimum() .maximum() .sum()
	*/
		count = isNaN(count) ? 2 : +count;
		var len = this.state.length,
			min = this.statistics.minimum('evaluations_step'),
			sum = this.statistics.sum('evaluations_step'),
			randoms = this.random.randoms(count, 0, sum - len * min),
			selected = [];
		randoms.sort(function (x, y) { return x-y; });
		this.state.forEach(function (element) {
			for (var i = 0; i < count; i++) {
				randoms[i] += i - len;
			}
			if (randoms[0] <= 0) {
				selected.push(element);
				randoms.shift();
			}
		});
		if (selected.length < count) { // Should not happen.
			selected = selected.concat(this.state.slice(0, count - selected.length));
		}
		return selected;
	}
}; // GeneticAlgorithm.selections

/** GeneticAlgorithm.crossovers:
	Bundle of standard crossover methods. A crossover function takes an 
	array of parent elements and returns an array of sibling elements.
*/
GeneticAlgorithm.crossovers = {
	/** GeneticAlgorithm.crossovers.singlepointCrossover(parents):
		Given two parents, returns an array of two new elements built with one
		half of each parent. The cutpoint is chosen randomly.
	*/
	singlepointCrossover: function singlepointCrossover(parents) {
		basis.raiseIf(!Array.isArray(parents) || parents.length < 2, "A two parent array is required.");
		var cut = this.random.randomInt(this.length - 1) + 1,
			values0 = parents[0].values,
			values1 = parents[1].values,
			elementConstructor = this.problem.representation;
		return [ 
			new elementConstructor(values0.slice(0, cut).concat(values1.slice(cut))),
			new elementConstructor(values1.slice(0, cut).concat(values0.slice(cut)))
		];
	}	
}; // GeneticAlgorithm.crossovers
	
/** GeneticAlgorithm.mutations:
	Bundle of standard mutation methods.
*/
GeneticAlgorithm.mutations = {
	/** GeneticAlgorithm.mutations.singlepointUniformMutation(element):
		Sets a randomly selected gene to a uniform random value.
	*/
	singlepointUniformMutation: function singlepointUniformMutation(element) {
		return element.modification(this.random.randomInt(element.length), element.randomValue());
	},
		
	/** GeneticAlgorithm.mutations.uniformMutation(maxPoints=Infinity):
		Builds a mutation function that makes at least one and up to maxPoints 
		mutations, changing a randomly selected gene to a uniform random value.
	*/
	uniformMutation: function uniformMutation(maxPoints) {
		max = isNaN(maxPoints) ? Infinity : +maxPoints;
		return function mutation(element) {
			var times = maxPoints;
			element = new element.constructor(element.values); // Copy element.
			do {
				element.values[this.random.randomInt(element.length)] = element.randomValue();
			} while (this.random.randomBool(this.mutationRate) && --times > 0);
			return element;
		};
	},
	
	/** GeneticAlgorithm.mutations.singlepointBiasedMutation(element):
		Sets a randomly selected gene to random deviation of its value, with a
		triangular distribution.
	*/
	singlepointBiasedMutation: function singlepointBiasedMutation(element) {
		return element.modification(this.random.randomInt(element.length),
			Math.max(element.minimumValue, Math.min(element.maximumValue, 
				element.values[i] + this.random.random() - this.random.random()
			))
		);
	}
}; // GeneticAlgorithm.mutations
