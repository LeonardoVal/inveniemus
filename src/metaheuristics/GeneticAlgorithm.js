/** # Genetic algorithm

Classic Holland's-style [genetic algorithms](http://en.wikipedia.org/wiki/Genetic_algorithm),
which is the base for many evolutionary computing variants.
*/
var GeneticAlgorithm = metaheuristics.GeneticAlgorithm = declare(Metaheuristic, {
	/** The constructor takes many parameters specific for this technique:
	*/
	constructor: function GeneticAlgorithm(params) {
		Metaheuristic.call(this, params); // Superconstructor call.
		initialize(this, params)
		/** + `expansionRate=0.5` is the amount of new elements generated by 
		crossover, as a ratio of the population size.
		*/
			.number('expansionRate', { defaultValue: 0.5, minimum: 0, coerce: true })
		/** + `mutationRate=0.2` is the chance of a new element (resulting from 
		crossover) mutating.
		*/
			.number('mutationRate', { defaultValue: 0.2, minimum: 0, maximum: 1, coerce: true })
		/** `selection(count)` is a function that selects count elements from 
		the current population. These will be the parents of the new elements in 
		the next generation.
		
		By default rank selection is used, a.k.a. fitness proportional to 
		position in the state.
		*/
			.func('selection', { defaultValue: GeneticAlgorithm.selections.rankSelection })
		/** `crossover(parents)` is a function implementing the genetic operator 
		that simulates reproduction with inheritance. The parents argument must 
		be an array of elements. The result is an array of elements.
		
		By default the single point crossover is used.
		*/
			.func('crossover', { defaultValue: GeneticAlgorithm.crossovers.singlepointCrossover })
		/** `mutation(element)` is a function implementing the genetic operator 
		that simulates biological mutation, making a random change in the 
		chromosome.
		
		By default a single point uniform mutation is used.
		*/
			.func('mutation', { defaultValue: GeneticAlgorithm.mutations.singlepointUniformMutation });
	},

	/** The population's (state) `expansion()` is the possibly mutated 
	crossovers of selected elements. How many is determined by `expansionRate`.
	*/
	expansion: function expansion() {
		var parents, childs, child,
			newElements = [],
			len = Math.floor(this.expansionRate * this.size);
		len += len % 2; // Make len even.
		for (var i = 0; i < len; i += 2) {
			parents = this.selection();
			childs = this.crossover(parents);
			for (var j = 0; j < childs.length; j++) {
				child = this.random.randomBool(this.mutationRate) ? this.mutation(childs[j]) : childs[j];
				newElements.push(child);
			}
		}
		return newElements;
	},
	
	toString: function toString() {
		return (this.constructor.name || 'GeneticAlgorithm')+ '('+ JSON.stringify(this) +')';
	}
}); // declare GeneticAlgorithm.

/** ## Selection methods #######################################################

`GeneticAlgorithm.selections` is a bundle of standard selection methods. A 
selection function takes the amount of elements to be selected and returns an 
array of selected elements. The implemented methods are:
*/
GeneticAlgorithm.selections = {
	/** + `rankSelection(count=2)` makes a selection where each element's 
		probability of being selected is proportional to its position in the state.
	*/
	rankSelection: function rankSelection(count) {
		count = isNaN(count) ? 2 : +count;
		var len = this.state.length,
			randoms = this.random.randoms(count, 0, len * (len + 1) / 2 - 1),
			selected = [];
		randoms.sort(function (x, y) { 
			return x - y; 
		});
		this.state.forEach(function (element) {
			for (var i = 0; i < count; i++) {
				randoms[i] += i - len;
			}
			if (randoms[0] <= 0) {
				selected.push(element);
				randoms.shift();
			}
		});
		if (selected.length < count) { // Should not happen.
			selected = selected.concat(this.state.slice(0, count - selected.length));
		}
		return selected;
	},
	
	/** + `rouletteSelection(count=2)` makes a selection where each element's 
		probability of being selected is proportional to its evaluation.
		Warning! This selection assumes the evaluation is being maximized.
	*/
	rouletteSelection: function rouletteSelection(count) { //FIXME
		count = isNaN(count) ? 2 : +count;
		var len = this.state.length,
			evaluationStat = this.statistics.stat({key: 'evaluation', step: this.step}),
			min = evaluationStat.minimum(),
			sum = evaluationStat.sum(),
			randoms = this.random.randoms(count, 0, sum - len * min),
			selected = [];
		randoms.sort(function (x, y) { return x-y; });
		this.state.forEach(function (element) {
			for (var i = 0; i < count; i++) {
				randoms[i] += i - len;
			}
			if (randoms[0] <= 0) {
				selected.push(element);
				randoms.shift();
			}
		});
		if (selected.length < count) { // Should not happen.
			selected = selected.concat(this.state.slice(0, count - selected.length));
		}
		return selected;
	}
}; // GeneticAlgorithm.selections

/** ## Crossover methods #######################################################

`GeneticAlgorithm.crossovers` is a bundle of standard crossover methods. A 
crossover function takes an array of parent elements and returns an array of 
sibling elements. The implemented methods are:
*/
GeneticAlgorithm.crossovers = {
	/** + `singlepointCrossover(parents)` given two parents returns an array of 
	two new elements built with one half of each parent. The cutpoint is chosen 
	randomly.
	*/
	singlepointCrossover: function singlepointCrossover(parents) {
		raiseIf(!Array.isArray(parents) || parents.length < 2, "A two parent array is required.");
		var cut = this.random.randomInt(this.length - 1) + 1,
			values0 = parents[0].values,
			values1 = parents[1].values,
			elementConstructor = this.problem.representation;
		return [ 
			new elementConstructor(values0.slice(0, cut).concat(values1.slice(cut))),
			new elementConstructor(values1.slice(0, cut).concat(values0.slice(cut)))
		];
	}	
}; // GeneticAlgorithm.crossovers
	
/** ## Mutation methods ########################################################

`GeneticAlgorithm.mutations` is a bundle of standard mutation methods. 
A mutation function takes an element and returns a new element which is a 
variation of the former. The implemented methods are:
*/
GeneticAlgorithm.mutations = {
	/** + `singlepointUniformMutation(element)` sets a randomly selected gene to 
	a uniform random value.
	*/
	singlepointUniformMutation: function singlepointUniformMutation(element) {
		return element.modification(this.random.randomInt(element.length), element.randomValue());
	},
		
	/** + `uniformMutation(maxPoints=Infinity)` builds a mutation function that 
	makes at least one and up to `maxPoints` mutations, changing a randomly 
	selected gene to a uniform random value.
	*/
	uniformMutation: function uniformMutation(maxPoints) {
		max = isNaN(maxPoints) ? Infinity : +maxPoints;
		return function mutation(element) {
			var times = maxPoints;
			element = new element.constructor(element.values); // Copy element.
			do {
				element.values[this.random.randomInt(element.length)] = element.randomValue();
			} while (this.random.randomBool(this.mutationRate) && --times > 0);
			return element;
		};
	},
	
	/** + `singlepointBiasedMutation(element)` sets a randomly selected gene to 
	random deviation of its value, with a triangular distribution.
	*/
	singlepointBiasedMutation: function singlepointBiasedMutation(element) {
		return element.modification(this.random.randomInt(element.length),
			Math.max(element.minimumValue, Math.min(element.maximumValue, 
				element.values[i] + this.random.random() - this.random.random()
			))
		);
	}
}; // GeneticAlgorithm.mutations
