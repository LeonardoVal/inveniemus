/** # Genetic algorithm

Classic Holland's-style [genetic algorithms](http://en.wikipedia.org/wiki/Genetic_algorithm),
which is the base for many evolutionary computing variants.
*/
var GeneticAlgorithm = metaheuristics.GeneticAlgorithm = declare(Metaheuristic, {
	/** The constructor takes many parameters specific for this technique:
	*/
	constructor: function GeneticAlgorithm(params) {
		Metaheuristic.call(this, params); // Superconstructor call.
		initialize(this, params)
		/** + `expansionRate=0.5` is the amount of new elements generated by crossover, as a ratio
		of the population size.
		*/
			.number('expansionRate', { defaultValue: 0.5, minimum: 0, coerce: true })
		/** + `mutationRate=0.2` is the chance of a new element (resulting from crossover) mutating.
		*/
			.number('mutationRate', { defaultValue: 0.2, minimum: 0, maximum: 1, coerce: true })
		/** + `selection(count)` is a function that selects count elements from the current 
		population. These will be the parents of the new elements in the next generation. By default
		rank selection is used, a.k.a. fitness proportional to position in the state.
		*/
			.func('selection', { defaultValue: GeneticAlgorithm.selections.rankSelection })
		/** + `crossover(parents)` is a function implementing the genetic operator that simulates 
		reproduction with inheritance. The parents argument must be an array of elements. The result
		is an array of elements. By default the single point crossover is used.
		*/
			.func('crossover', { defaultValue: GeneticAlgorithm.crossovers.singlepointCrossover })
		/** `mutation(element)` is a function implementing the genetic operator that simulates 
		biological mutation, making a random change in the chromosome. By default a single point 
		uniform mutation is used.
		*/
			.func('mutation', { defaultValue: GeneticAlgorithm.mutations.singlepointUniformMutation });
	},

	/** The population's (state) `expansion()` is the possibly mutated crossovers of selected 
	elements. How many is determined by `expansionRate`.
	*/
	expansion: function expansion() {
		var parents, childs, child,
			newElements = [],
			len = Math.floor(this.expansionRate * this.size);
		len += len % 2; // Make len even.
		for (var i = 0; i < len; i += 2) {
			parents = this.selection();
			childs = this.crossover(parents);
			for (var j = 0; j < childs.length; j++) {
				child = this.random.randomBool(this.mutationRate) ? this.mutation(childs[j]) : childs[j];
				newElements.push(child);
			}
		}
		this.onExpand();
		return newElements;
	},
	
	/** ## Selection methods #######################################################################

	`GeneticAlgorithm.selections` is a bundle of standard selection methods. A selection function 
	takes the amount of elements to be selected and returns an array of selected elements. The 
	implemented methods are:
	*/
	'static selections': {
		/** + `rankSelection(count=2)` makes a selection where each element's probability of being 
		selected is proportional to its position in the state.
		*/
		rankSelection: function rankSelection(count) {
			count = isNaN(count) ? 2 : +count;
			var len = this.state.length,
				randoms = this.random.randoms(count, 0, len * (len + 1) / 2 - 1),
				selected = [];
			randoms.sort(function (x, y) { 
				return x - y; 
			});
			this.state.forEach(function (element) {
				for (var i = 0; i < count; i++) {
					randoms[i] += i - len;
				}
				if (randoms[0] <= 0) {
					selected.push(element);
					randoms.shift();
				}
			});
			if (selected.length < count) { // Should not happen.
				selected = selected.concat(this.state.slice(0, count - selected.length));
			}
			return selected;
		},
		
		/** + `rouletteSelection(count=2)` makes a selection where each element's probability of being 
		selected is proportional to its evaluation. Warning! This selection assumes the evaluation is 
		being maximized.
		*/
		rouletteSelection: function rouletteSelection(count) { //FIXME
			count = isNaN(count) ? 2 : count |0;
			var len = this.state.length,
				evaluationStat = this.statistics.stat({key: 'evaluation', step: this.step}),
				min = evaluationStat.minimum(),
				sum = evaluationStat.sum(),
				randoms = this.random.randoms(count, 0, sum - len * min),
				selected = [];
			randoms.sort(function (x, y) { return x-y; });
			this.state.forEach(function (element) {
				for (var i = 0; i < count; i++) {
					randoms[i] += i - len;
				}
				if (randoms[0] <= 0) {
					selected.push(element);
					randoms.shift();
				}
			});
			if (selected.length < count) { // Should not happen.
				selected = selected.concat(this.state.slice(0, count - selected.length));
			}
			return selected;
		},
		
		/** + [`stochasticUniversalSamplingSelection(count)`](http://en.wikipedia.org/wiki/Stochastic_universal_sampling)
		is a less biased version of the roulette selection method.
		*/
		stochasticUniversalSamplingSelection: function stochasticUniversalSamplingSelection(count) {
			count = isNaN(count) ? 2 : count |0;
			var state = this.state,
				totalFitness = iterable(state).select('evaluation').sum(),
				p = totalFitness / count;
			return base.Iterable.iterate(function (x) { 
				return x + p; 
			}, this.random.randomInt(p), count).map(function (pointer) {
				var sum = 0;
				for (var i = 0; i < state.length; ++i) {
					sum += state[i].evaluation;
					if (sum >= pointer) {
						return state[i];
					}
				}
				return state[state.length - 1]; // Very improbable.
			}).toArray();
		},		
	}, // GeneticAlgorithm.selections

	/** ## Crossover methods #######################################################################

	`GeneticAlgorithm.crossovers` is a bundle of standard crossover methods. A crossover function 
	takes an array of parent elements and returns an array of sibling elements. The implemented
	methods are:
	*/
	'static crossovers': {
		/** + `singlepointCrossover(parents)` given two parents returns an array of two new elements
		built with one half of each parent. The cutpoint is chosen randomly.
		*/
		singlepointCrossover: function singlepointCrossover(parents) {
			raiseIf(!Array.isArray(parents) || parents.length < 2, "A two parent array is required.");
			var cut = this.random.randomInt(this.length - 1) + 1,
				values0 = parents[0].values,
				values1 = parents[1].values;
			return [ 
				this.problem.newElement(values0.slice(0, cut).concat(values1.slice(cut))),
				this.problem.newElement(values1.slice(0, cut).concat(values0.slice(cut)))
			];
		},
		
		/** + `twopointCrossover(parents)` given two parents returns an array of two new elements:
		the first one with two parts of the first parent and one part of the second parent, and the 
		second one assembled viceversa. The two cutpoints are chosen randomly.
		*/
		twopointCrossover: function twopointCrossover(parents) {
			raiseIf(!Array.isArray(parents) || parents.length < 2, "A two parent array is required.");
			var cut1 = this.random.randomInt(this.length - 1) + 1,
				cut2 = this.random.randomInt(this.length - 1) + 1,
				values0 = parents[0].values,
				values1 = parents[1].values;
			return [ 
				this.problem.newElement(values0.slice(0, cut1).concat(values1.slice(cut1, cut2)).concat(values0.slice(cut2))),
				this.problem.newElement(values1.slice(0, cut1).concat(values0.slice(cut1, cut2)).concat(values1.slice(cut2)))
			];
		},
		
		/** + `uniformCrossover(parents)` creates as many children as the given parents, with each
		value taken randomly from any of the parents.
		*/
		uniformCrossover: function uniformCrossover(parents, count) {
			count = isNaN(count) ? parents.length : count|0;
			var result = [],
				length = this.problem.elementLength(),
				random = this.random,
				values;
			for (var i = 0; i < count; ++i) {
				values = [];
				for (var j = 0; j < length; ++j) {
					values.push(random.choice(parents).values[j]);
				}
				result.push(this.problem.newElement(values));
			}
			return result;
		}
	}, // GeneticAlgorithm.crossovers
	
	/** ## Mutation methods ########################################################################

	`GeneticAlgorithm.mutations` is a bundle of standard mutation methods. A mutation function takes 
	an element and returns a new element which is a variation of the former. The implemented methods
	are:
	*/
	'static mutations': {
		/** + `singlepointUniformMutation(element)` sets a randomly selected gene to a uniform
		random value.
		*/
		singlepointUniformMutation: function singlepointUniformMutation(element) {
			return element.modification(this.random.randomInt(element.length), this.random.random());
		},
			
		/** + `uniformMutation(maxPoints=Infinity)` builds a mutation function that makes at least 
		one and up to `maxPoints` mutations, changing a randomly selected gene to a uniform random
		value.
		*/
		uniformMutation: function uniformMutation(maxPoints) {
			max = isNaN(maxPoints) ? Infinity : +maxPoints;
			return function mutation(element) {
				var times = maxPoints;
				element = this.problem.newElement(element.values); // Copy element.
				do {
					element.values[this.random.randomInt(element.length)] = this.random.random();
				} while (this.random.randomBool(this.mutationRate) && --times > 0);
				return element;
			};
		},
		
		/** + `singlepointBiasedMutation(element)` sets a randomly selected gene to random deviation
		of its value, with a triangular distribution.
		*/
		singlepointBiasedMutation: function singlepointBiasedMutation(element) {
			var random = this.random, 
				i = random.randomInt(element.length);
			return element.modification(i, element.values[i] + random.random() - random.random());
		},
		
		/** + `recombinationMutation(element)` swaps two values of the element at random.
		*/
		recombinationMutation: function recombinationMutation(element) {
			var values = element.values.slice(),
				i1 = this.random.randomInt(element.length),
				v1 = values[i1],
				i2 = this.random.randomInt(element.length), v2;
			if (i1 === i2) {
				i2 = (i2 + 1) % element.length;
			}
			values[i1] = values[i2];
			values[i2] = v1;
			return this.problem.newElement(values);
		}
	}, // GeneticAlgorithm.mutations
	
	toString: function toString() {
		return (this.constructor.name || 'GeneticAlgorithm')+ '('+ JSON.stringify(this) +')';
	}
}); // declare GeneticAlgorithm.
